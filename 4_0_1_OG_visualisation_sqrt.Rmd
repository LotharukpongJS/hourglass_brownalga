---
title: "4.0.1 OG visualisation (sqrt)"
output:
  html_document:
    fig_width: 6
    fig_height: 4
    df_print: paged
editor_options: 
  chunk_output_type: inline
---

# Orthogroup expression analysis

Same as `4.0 OG visualisation` but I was wondering what would the profiles look like if I use the `sqrt` transformed data instead of `log` or variance stabilised transformations.

See some debates:

https://twitter.com/NimwegenLab/status/1694416253895475214
https://www.journals.uchicago.edu/doi/abs/10.1086/658408

etc.

```{r}
library(tidyverse)
library(ggfortify)
```

```{r}
sample_info_fd <-
  readr::read_csv("data/sample_info_fd.csv")
sample_info_fs <-
  readr::read_csv("data/sample_info_fs.csv")
sample_info_ec <-
  readr::read_csv("data/sample_info_ec.csv")

sample_info_fd_embryo <-
  sample_info_fd %>%
  dplyr::filter(Stage %in% c("E1", "E2", "E3", "E4", "E5", "E6")) %>%
  dplyr::mutate(LibLab = str_c(Species, "_", Stage, "_", Replicate))
sample_info_fs_embryo <-
  sample_info_fs %>%
  dplyr::filter(Stage %in% c("24H", "48H", "1w", "3w", "4w")) %>%
  dplyr::mutate(Replicate = case_when(
    LibName == "Fs_X_zygotes_48h_1" ~ 4,
    LibName == "Fs_X_zygotes_48h_2" ~ 5,
    LibName == "Fs_X_zygotes_48h_3" ~ 6,
    TRUE ~ Replicate
  )) %>%
  mutate(LibLab = str_c(Species, "_", Stage, "_", Replicate))
```

```{r}
Fs_abundance <-
  readr::read_csv(file = "data/Fs_OG_abundance.csv")
Fs_counts <-
  readr::read_csv(file = "data/Fs_OG_counts.csv")
Fd_abundance <-
  readr::read_csv(file = "data/Fd_OG_abundance.csv")
Fd_counts <-
  readr::read_csv(file = "data/Fd_OG_counts.csv")
Ec_abundance <-
  readr::read_csv(file = "data/Ec_OG_abundance.csv")
Ec_counts <-
  readr::read_csv(file = "data/Ec_OG_counts.csv")
```


# PCA using OGs

```{r}
selectGenes <- function(counts, min.count=2){
  keep <-
    counts[rowMeans(counts)>min.count, ]
  return(keep)
}
```

To minimise differences between species, I remove OGs with low counts.

```{r}
combined_metatable <- 
  rbind(sample_info_fs_embryo, sample_info_fd_embryo) %>%
  relocate(LibName)
```

```{r}
merged_TPM_pre <- 
  merge(Fs_abundance, Fd_abundance, by = "OG") %>%
  dplyr::select(1, combined_metatable$LibName)
merged_TPM <- 
  data.frame(row.names = merged_TPM_pre[,1], merged_TPM_pre[,-1], check.names = FALSE)
merged_TPM.filt <-
  as.matrix(merged_TPM) %>%
  selectGenes(min.count=10)
```

Through the filtering function, I retain 2889 / 3724 OGs

```{r}
# rlog_TPM <- DESeq2::rlog(merged_TPM.filt %>% round(0))
# log2_TPM <- log2(merged_TPM.filt+1)
sqrt_TPM <- sqrt(merged_TPM.filt)
# tpm10_TPM <- (merged_TPM.filt > 10) * 1
```

# Distance metrics

Here, we use distance metrics to quantify how distant the stages are from each other across _Fucus_ species and maybe even in _Ectocarpus_.

```{r}
library(philentropy)
```

```{r}
ncol_Fs <- grep( "Fs" , colnames( sqrt_TPM ) )
ncol_Fd <- grep( "Fd" , colnames( sqrt_TPM ) )
```

## Using sqrt(TPM)

```{r}
sqrt_TPM_renamed <- sqrt_TPM
base::colnames(sqrt_TPM_renamed) <- combined_metatable$LibLab
```

### Pearson correlation

Linear relationship

```{r fig.height = 4, fig.width = 5}
M = cor(x = sqrt_TPM_renamed[,ncol_Fs], 
        y = sqrt_TPM_renamed[,ncol_Fd], 
        method = "pearson")

M_melt <- reshape2::melt(M)
ggplot2::ggplot(M_melt, aes(x = Var2, y = Var1, fill = value)) +
  ggplot2::geom_tile() +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggplot2::scale_fill_gradient(low = "white", high = "#DC0000FF") +
  ggplot2::labs(
    x = "Fucus distichus samples",
    y = "Fucus serratus samples",
    title = "Pearson correlation (sqrt)",
    fill = "Correlation") +
  ggplot2::coord_flip()
```

```{r fig.height = 3, fig.width = 4.5}
tmp1 <- sample_info_fd_embryo %>% 
  select(Var2 = LibLab, Stage) %>% 
  full_join(M_melt, multiple = "all") %>%
  dplyr::rename(Fd = Stage)

tmp2 <- sample_info_fs_embryo %>% 
  select(Var1 = LibLab, Stage) %>% 
  full_join(tmp1, multiple = "all") %>%
  dplyr::rename(Fs = Stage)

tmp2$Fs <- factor(tmp2$Fs, levels = unique(tmp2$Fs))
tmp2$Fd <- factor(tmp2$Fd, levels = unique(tmp2$Fd))
tmp2 %>% group_by(Fs, Fd) %>% summarise(median_corr = median(value)) %>%
  ggplot(aes(x = Fs, y = Fd, fill = median_corr)) +
  geom_tile() +
  geom_text(aes(label = paste0(round(median_corr,3))), color = "black") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_gradient(low = "white", high = "#DC0000FF") +
  labs(x = "Fucus serratus samples",
       y = "Fucus distichus samples",
       title = "Pearson correlation (sqrt)",
       fill = "median(correlation)")
```

### Spearman correlation

Monotonic relationship

```{r fig.height = 4, fig.width = 5}
sqrt_TPM_renamed <- sqrt_TPM
base::colnames(sqrt_TPM_renamed) <- combined_metatable$LibLab

M = cor(x = sqrt_TPM_renamed[,ncol_Fs], 
        y = sqrt_TPM_renamed[,ncol_Fd], 
        method = "spearman")

M_melt <- reshape2::melt(M)
ggplot2::ggplot(M_melt, aes(x = Var2, y = Var1, fill = value)) +
  ggplot2::geom_tile() +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggplot2::scale_fill_gradient(low = "white", high = "#DC0000FF") +
  ggplot2::labs(
    x = "Fucus distichus samples",
    y = "Fucus serratus samples",
    title = "Spearman correlation (sqrtTPM)",
    fill = "Correlation") +
  ggplot2::coord_flip()
```

```{r fig.height = 3, fig.width = 4.5}
tmp1 <- sample_info_fd_embryo %>% 
  select(Var2 = LibLab, Stage) %>% 
  full_join(M_melt, multiple = "all") %>%
  dplyr::rename(Fd = Stage)

tmp2 <- sample_info_fs_embryo %>% 
  select(Var1 = LibLab, Stage) %>% 
  full_join(tmp1, multiple = "all") %>%
  dplyr::rename(Fs = Stage)

tmp2$Fs <- factor(tmp2$Fs, levels = unique(tmp2$Fs))
tmp2$Fd <- factor(tmp2$Fd, levels = unique(tmp2$Fd))
tmp2 %>% group_by(Fs, Fd) %>% summarise(median_corr = median(value)) %>%
  ggplot(aes(x = Fs, y = Fd, fill = median_corr)) +
  geom_tile() +
  geom_text(aes(label = paste0(round(median_corr,3))), color = "black") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_gradient(low = "white", high = "#DC0000FF") +
  labs(x = "Fucus serratus samples",
       y = "Fucus distichus samples",
       title = "Spearman correlation (sqrt)",
       fill = "median(correlation)")
```

### Manhattan distance

Manhattan distance is a distance metric used to measure the distance between two points in a grid-like system, such as a city block or a chessboard. It is calculated as the sum of the absolute differences between the coordinates of the two points. The term “Manhattan” is used because the grid-like structure and the right-angled turns of the streets in Manhattan, New York, resemble a chessboard. The Manhattan distance is also known as the L1 norm or taxicab distance. It is commonly used in machine learning and data science to measure similarity between data points or to cluster data.

It is L_{1} norm unlike Euclidean L_{2} norm.

Because it uses absolute values instead of exponentiation and rooting, it is said to be *more robust to outliers* compared to the euclidean distance. Additionally, the modulus is much faster to compute than exponentiation. It is a special case of the Minkowski distance.

```{r fig.height = 4, fig.width = 5}
DM <- philentropy::distance(t(sqrt_TPM_renamed), use.row.names = TRUE, method = "manhattan")
DM2 <- DM[ncol_Fs, ncol_Fd]

M_melt <- reshape2::melt(DM2)
ggplot2::ggplot(M_melt, aes(x = Var2, y = Var1, fill = value)) +
  ggplot2::geom_tile() +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggplot2::scale_fill_gradient(low = "white", high = "#3C5488FF") +
  ggplot2::labs(
    x = "Fucus distichus samples",
    y = "Fucus serratus samples",
    title = "Manhattan distance (sqrt)",
    fill = "Distance") +
  ggplot2::coord_flip()
```

```{r fig.height = 3, fig.width = 4.5}
tmp1 <- sample_info_fd_embryo %>% 
  select(Var2 = LibLab, Stage) %>% 
  full_join(M_melt, multiple = "all") %>%
  dplyr::rename(Fd = Stage)

tmp2 <- sample_info_fs_embryo %>% 
  select(Var1 = LibLab, Stage) %>% 
  full_join(tmp1, multiple = "all") %>%
  dplyr::rename(Fs = Stage)

tmp2$Fs <- factor(tmp2$Fs, levels = unique(tmp2$Fs))
tmp2$Fd <- factor(tmp2$Fd, levels = unique(tmp2$Fd))
tmp2 %>% group_by(Fs, Fd) %>% summarise(median_corr = median(value)) %>%
  ggplot(aes(x = Fs, y = Fd, fill = median_corr)) +
  geom_tile() +
  geom_text(aes(label = paste0(round(median_corr,0))), color = "black") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_gradient(low = "white", high = "#3C5488FF") +
  labs(x = "Fucus serratus samples",
       y = "Fucus distichus samples",
       title = "Manhattan distance (sqrt)",
       fill = "median(distance)")
```

### Euclidean distance

Euclidean distance is a measure of the straight-line distance between two points in a multi-dimensional space. It is calculated as the square root of the sum of the squared differences between the corresponding coordinates of the two points. The Euclidean distance is commonly used in clustering and classification algorithms, as well as in distance-based data analysis and visualization techniques.

Euclidean is [not ideal for high-dimension data](https://stats.stackexchange.com/questions/99171/why-is-euclidean-distance-not-a-good-metric-in-high-dimensions/99191#99191). But it is commonly used.

```{r fig.height = 4, fig.width = 5}
DM <- philentropy::distance(t(sqrt_TPM_renamed), use.row.names = TRUE, method = "euclidean")
DM2 <- DM[ncol_Fs, ncol_Fd]

M_melt <- reshape2::melt(DM2)
ggplot2::ggplot(M_melt, aes(x = Var2, y = Var1, fill = value)) +
  ggplot2::geom_tile() +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  ggplot2::scale_fill_gradient(low = "white", high = "#3C5488FF") +
  ggplot2::labs(
    x = "Fucus distichus samples",
    y = "Fucus serratus samples",
    title = "Euclidean distance (sqrt)",
    fill = "Distance") +
  ggplot2::coord_flip()
```

```{r fig.height = 3, fig.width = 4.5}
tmp1 <- sample_info_fd_embryo %>% 
  select(Var2 = LibLab, Stage) %>% 
  full_join(M_melt, multiple = "all") %>%
  dplyr::rename(Fd = Stage)

tmp2 <- sample_info_fs_embryo %>% 
  select(Var1 = LibLab, Stage) %>% 
  full_join(tmp1, multiple = "all") %>%
  dplyr::rename(Fs = Stage)

tmp2$Fs <- factor(tmp2$Fs, levels = unique(tmp2$Fs))
tmp2$Fd <- factor(tmp2$Fd, levels = unique(tmp2$Fd))
tmp2 %>% group_by(Fs, Fd) %>% summarise(median_corr = median(value)) %>%
  ggplot(aes(x = Fs, y = Fd, fill = median_corr)) +
  geom_tile() +
  geom_text(aes(label = paste0(round(median_corr,1))), color = "black") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_gradient(low = "white", high = "#3C5488FF") +
  labs(x = "Fucus serratus samples",
       y = "Fucus distichus samples",
       title = "Euclidean distance (sqrt)",
       fill = "median(distance)")
```

### JSD metric

Jensen-Shannon distance is a statistical distance metric that measures the similarity between two probability distributions. It is often used in data analysis and machine learning for clustering, classification, and anomaly detection tasks.

```{r fig.height = 4, fig.width = 5}
mat_normalized <- apply(sqrt_TPM_renamed, 2, function(x) x/sum(x)) %>% as.data.frame()
# colSums(mat_normalized)
DM <- philentropy::distance(t(mat_normalized), use.row.names = TRUE, method = "jensen-shannon")
DM2 <- DM[ncol_Fs, ncol_Fd]
DM3 <- sqrt(DM2)

M_melt <- reshape2::melt(DM3)
ggplot(M_melt, aes(x = Var2, y = Var1, fill = value)) +
  geom_tile() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_gradient(low = "white", high = "#3C5488FF") +
  labs(x = "Fucus distichus samples",
       y = "Fucus serratus samples",
       title = "JSD metric (norm. sqrt)",
       fill = "Distance") +
  coord_flip()
```


```{r fig.height = 3, fig.width = 4.5}
tmp1 <- sample_info_fd_embryo %>% 
  select(Var2 = LibLab, Stage) %>% 
  full_join(M_melt, multiple = "all") %>%
  dplyr::rename(Fd = Stage)

tmp2 <- sample_info_fs_embryo %>% 
  select(Var1 = LibLab, Stage) %>% 
  full_join(tmp1, multiple = "all") %>%
  dplyr::rename(Fs = Stage)

tmp2$Fs <- factor(tmp2$Fs, levels = unique(tmp2$Fs))
tmp2$Fd <- factor(tmp2$Fd, levels = unique(tmp2$Fd))
tmp2 %>% group_by(Fs, Fd) %>% summarise(median_corr = median(value)) %>%
  ggplot(aes(x = Fs, y = Fd, fill = median_corr)) +
  geom_tile() +
  geom_text(aes(label = paste0(round(median_corr,3))), color = "black") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_gradient(low = "white", high = "#3C5488FF") +
  labs(x = "Fucus serratus samples",
       y = "Fucus distichus samples",
       title = "JSD metric (norm. sqrt)",
       fill = "median(distance)")
```

```{r}
devtools::session_info()
```